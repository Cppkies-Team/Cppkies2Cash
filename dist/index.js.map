{"version":3,"file":"index.js","sources":["../src/lib/eventemitter.ts","../src/helpers.ts","../src/hooks.ts","../src/index.ts"],"sourcesContent":["type EventListenerFunction<\r\n\tT extends Record<string, [unknown, unknown]>,\r\n\tN extends keyof T\r\n> = (src: T[N][0]) => T[N][1]\r\n\r\ntype EventList<T extends Record<string, [unknown, unknown]>> = {\r\n\t[P in keyof T]: EventListenerFunction<T, P>[]\r\n}\r\n\r\n/**\r\n * A small implementation of node's EventEmitter with return value support\r\n */\r\n\r\nexport class ReturnableEventEmitter<\r\n\tT extends Record<string, [unknown, unknown]>\r\n> {\r\n\t_events = {} as EventList<T>\r\n\r\n\t/**\r\n\t * Registers an event listener which is called each time the event is emitted\r\n\t * @param name Name of the hook\r\n\t * @param func The event listener function\r\n\t */\r\n\ton<N extends keyof T>(name: N, func: EventListenerFunction<T, N>): void {\r\n\t\tif (!this._events[name]) {\r\n\t\t\tthis._events[name] = [func]\r\n\t\t} else this._events[name].push(func)\r\n\t}\r\n\t/**\r\n\t * Registers an event listener which is called for the first time the event is emitted\r\n\t * @param name Name of the hook\r\n\t * @param func The event listener function\r\n\t */\r\n\tonce<N extends keyof T>(name: N, func: EventListenerFunction<T, N>): void {\r\n\t\tthis.on(name, arg => {\r\n\t\t\tthis.off(name, func)\r\n\t\t\treturn func(arg)\r\n\t\t})\r\n\t}\r\n\t/**\r\n\t * Removes an event listener which was registered before\r\n\t * @param name Name of the hook\r\n\t * @param func The event listener function\r\n\t */\r\n\toff<N extends keyof T>(name: N, func: EventListenerFunction<T, N>): void {\r\n\t\tthis._events[name].splice(this._events[name].indexOf(func), 1)\r\n\t}\r\n\r\n\t// Sorry for the minor type mess, I blame typescript\r\n\t/**\r\n\t * Emits the event, triggering all registered event listeners under the event name and modifying the given value\r\n\t * @param name The name of the event\r\n\t * @param startingValue The starting value for the listeners\r\n\t */\r\n\temit<N extends keyof T>(\r\n\t\tname: N,\r\n\t\t...startingValue: T[N][0] extends void ? [undefined?] : [T[N][0]]\r\n\t): T[N][1] {\r\n\t\tlet retVal: T[N][0] | T[N][1] = startingValue[0]\r\n\t\tif (!this._events[name]) this._events[name] = []\r\n\t\tfor (const func of this._events[name]) retVal = func(retVal)\r\n\t\treturn retVal\r\n\t}\r\n\t/**\r\n\t * Emits the event, triggering all registered event listeners under the event name and *not* modifying the given value\r\n\t * @param name The name of the event\r\n\t * @param startingValue The starting value for the listeners\r\n\t */\r\n\tconstEmit<N extends keyof T>(\r\n\t\tname: N,\r\n\t\t...startingValue: T[N][0] extends void ? [undefined?] : [T[N][0]]\r\n\t): void {\r\n\t\tif (!this._events[name]) this._events[name] = []\r\n\t\tfor (const func of this._events[name]) func(startingValue[0])\r\n\t}\r\n}\r\n","/**\r\n * The common type for a value, can be either the value or a function that returns a value with the type.\r\n */\r\nexport type CommonValue<T> = T | (() => T)\r\n/**\r\n * A helper function which converts a common value to a value\r\n * @param value The common value to convert\r\n * @helper\r\n */\r\nexport function getValue<T>(value: CommonValue<T>): T {\r\n\tif (value instanceof Function) return value()\r\n\treturn value\r\n}\r\n/**\r\n * A helper function which escapes special regex characters.\r\n * @param str The string to escape\r\n * @helper\r\n */\r\nexport function escapeRegExp(str: string): string {\r\n\t// eslint-disable-next-line no-useless-escape\r\n\treturn str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\")\r\n}\r\n/**\r\n * The parameters of an injection, in order: `source`, `target`, `where`\r\n */\r\nexport type InjectParams = [\r\n\tstring | RegExp | null,\r\n\tstring,\r\n\t\"before\" | \"replace\" | \"after\"\r\n]\r\n/**\r\n * A helper helper function, which does a single inject to code\r\n * @param source The code to perform the inject on\r\n * @param config The configuration of the inject\r\n * @helper\r\n * @helperhelper\r\n */\r\nfunction doSingleInject(source: string, config: InjectParams): string {\r\n\tconst sliceMode = config[0] === null\r\n\t// Do this to mute typescript silly wrong errors\r\n\tlet regex = new RegExp(\"\")\r\n\tif (config[0] !== null) {\r\n\t\tif (typeof config[0] === \"string\")\r\n\t\t\tregex = new RegExp(escapeRegExp(config[0]), \"g\")\r\n\t\telse regex = config[0]\r\n\t\tif (!regex.test(source)) console.warn(\"Nothing to inject.\")\r\n\t}\r\n\r\n\tconst findStart = /(\\)[^{]*{)/\r\n\tconst findEnd = /(}?)$/\r\n\r\n\tswitch (config[2]) {\r\n\t\tcase \"before\":\r\n\t\t\tif (sliceMode) source = source.replace(findStart, `$1${config[1]}`)\r\n\t\t\telse source = source.replace(regex, `${config[1]}${config[0]}`)\r\n\t\t\tbreak\r\n\t\tcase \"replace\":\r\n\t\t\tif (sliceMode) source = config[1]\r\n\t\t\telse source = source.replace(regex, config[1])\r\n\t\t\tbreak\r\n\t\tcase \"after\":\r\n\t\t\tif (sliceMode) source = source.replace(findEnd, `${config[1]}$1`)\r\n\t\t\telse source = source.replace(regex, `${config[0]}${config[1]}`)\r\n\t\t\tbreak\r\n\t\tdefault:\r\n\t\t\tthrow new Error('where Parameter must be \"before\", \"replace\" or \"after\"')\r\n\t}\r\n\treturn source\r\n}\r\n/**\r\n * A helper function which replaces(or appends) code in a function, returning the new function, and it's eval free!\r\n * @param func The source function\r\n * @param source What to replace, can be null for slicing\r\n * @param target What to put instead of (or before/after) the source\r\n * @param where Where to insert or replace your injection\r\n * @param context The optional context to use\r\n * @helper\r\n */\r\nexport function injectCode<\r\n\tT extends\r\n\t\t| ((...args: unknown[]) => unknown)\r\n\t\t| (new (...args: unknown[]) => unknown)\r\n>(\r\n\tfunc: T,\r\n\tsource: string | RegExp | null,\r\n\ttarget: string,\r\n\twhere: \"before\" | \"replace\" | \"after\",\r\n\tcontext: object = {}\r\n): T {\r\n\tconst newFunc = Function(\r\n\t\t...Object.keys(context),\r\n\t\t`return (${doSingleInject(func.toString(), [source, target, where])})`\r\n\t)(...Object.values(context))\r\n\tnewFunc.prototype = func.prototype\r\n\treturn newFunc\r\n}\r\n\r\n/**\r\n * A helper function which replaces(or appends) code in a function, returning the new function, and it's eval free!\r\n * @param func The source function\r\n * @param injections The injections to apply, the parameters of an injection, in order: `source`, `target`, `where`\r\n * @param context The optional context to use\r\n * @helper\r\n */\r\nexport function injectCodes<\r\n\tT extends\r\n\t\t| ((...args: unknown[]) => unknown)\r\n\t\t| (new (...args: unknown[]) => unknown)\r\n>(func: T, injections: InjectParams[], context: object = {}): T {\r\n\tlet newStr = func.toString()\r\n\tfor (const injection of injections) newStr = doSingleInject(newStr, injection)\r\n\tconst newFunc = Function(\r\n\t\t...Object.keys(context),\r\n\t\t`return (${newStr})`\r\n\t)(...Object.values(context))\r\n\tnewFunc.prototype = func.prototype\r\n\treturn newFunc\r\n}\r\n","import { ReturnableEventEmitter } from \"./lib/eventemitter\"\nimport { injectCodes } from \"./helpers\"\n\ntype Hooks = ReturnableEventEmitter<{\n\ttrail: [number, number]\n\tcoinImageResolve: [HTMLImageElement, HTMLImageElement]\n}>\n\ndeclare global {\n\tinterface Window {\n\t\t__C2C_INTERNAL__: { hooks: Hooks }\n\t}\n}\n\nconst hooks: Hooks = new ReturnableEventEmitter()\nexport const on = hooks.on.bind(hooks)\n\nexport function createHooks(hooks: Hooks): Hooks {\n\t// @ts-expect-error Typescript doesn't like assigning to global classes\n\tCoin = injectCodes(Coin, [\n\t\t[\"trail=1\", 'trail=__C2C_INTERNAL__.hooks.emit(\"trail\", 1)', \"replace\"],\n\t\t[\n\t\t\t\"pic['coin3.png']\",\n\t\t\t\"__C2C_INTERNAL__.hooks.emit(\\\"coinImageResolve\\\", pic['coin3.png'])\",\n\t\t\t\"replace\",\n\t\t],\n\t])\n\twindow.__C2C_INTERNAL__ = { hooks }\n\treturn hooks\n}\n\nexport default hooks\n","// Dumb dts-bundle-generator\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"./typings.d.ts\" />\n\nimport hooks, { createHooks } from \"./hooks\"\n\ncreateHooks(hooks)\n\nexport { default as hooks, on } from \"./hooks\"\n"],"names":[],"mappings":"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"}